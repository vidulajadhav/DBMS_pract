Example Database: CompanyDB


CREATE TABLE Department (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    salary INT,
    dept_id INT,
    manager_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);

Insert sample data:
INSERT INTO Department VALUES (1, 'HR'), (2, 'IT'), (3, 'Finance');

INSERT INTO Employee VALUES
(101, 'Amit', 50000, 1, NULL),
(102, 'Riya', 60000, 1, 101),
(103, 'Rahul', 70000, 2, 101),
(104, 'Sneha', 80000, 2, 102),
(105, 'Karan', 55000, 3, 101);

ðŸ§© 1. INNER JOIN
SELECT e.emp_name, d.dept_name
FROM Employee e
INNER JOIN Department d ON e.dept_id = d.dept_id;


ðŸ§  Explanation:
Shows employees with their department names. Only matching records appear.
(All dept_ids 1, 2, 3 exist in Department, so no one is excluded.)

ðŸ§© 2. LEFT JOIN
SELECT e.emp_name, d.dept_name
FROM Employee e
LEFT JOIN Department d ON e.dept_id = d.dept_id;


ðŸ§  Explanation:
Shows all employees, even if their department has no match (department data will show as NULL).
(If any employee had a missing or unmatched dept_id, that row would show NULL in dept_name.)

ðŸ§© 3. RIGHT JOIN
SELECT e.emp_name, d.dept_name
FROM Employee e
RIGHT JOIN Department d ON e.dept_id = d.dept_id;


ðŸ§  Explanation:
Shows all departments, including those without employees.
(ðŸ§  If a department had no employees, it would appear with emp_name = NULL.)

ðŸ§© 4. FULL OUTER JOIN (works in PostgreSQL / Oracle)
SELECT e.emp_name, d.dept_name
FROM Employee e
LEFT JOIN Department d ON e.dept_id = d.dept_id

UNION

SELECT e.emp_name, d.dept_name
FROM Employee e
RIGHT JOIN Department d ON e.dept_id = d.dept_id;


ðŸ§  Explanation:
Combines LEFT and RIGHT joins â€” shows all employees and departments whether they match or not.
UNION automatically removes duplicates, so this behaves like a full outer join.

ðŸ§© 5. CROSS JOIN
SELECT e.emp_name, d.dept_name
FROM Employee e
CROSS JOIN Department d;


ðŸ§  Explanation:
Creates every possible combination between employees and departments (Cartesian product).

ðŸ§© 6. SIMPLE SUBQUERY (Single Row)
SELECT emp_name, salary
FROM Employee
WHERE salary > (SELECT AVG(salary) FROM Employee);


ðŸ§  Explanation:
Selects employees whose salary is above the companyâ€™s average salary.

ðŸ§© 7. MULTI-ROW SUBQUERY (IN keyword)
SELECT emp_name
FROM Employee
WHERE dept_id IN (SELECT dept_id FROM Department WHERE dept_name IN ('HR', 'IT'));


ðŸ§  Explanation:
Lists employees who belong to HR or IT departments.

ðŸ§© 8. CORRELATED SUBQUERY
SELECT emp_name, salary
FROM Employee e1
WHERE salary > (SELECT AVG(salary) FROM Employee e2 WHERE e1.dept_id = e2.dept_id);


ðŸ§  Explanation:
Finds employees whose salary is above the average salary of their department.
The inner query depends on the outer query.

ðŸ§© 9. CREATE AND USE A VIEW
CREATE VIEW emp_details AS
SELECT e.emp_id, e.emp_name, e.salary, d.dept_name
FROM Employee e
JOIN Department d ON e.dept_id = d.dept_id;

-- Use the view
SELECT * FROM emp_details WHERE salary > 60000;


ðŸ§  Explanation:
Creates a reusable virtual table (emp_details) that joins Employee and Department info.

ðŸ§© 10. NESTED VIEW with Subquery
CREATE VIEW high_salary AS
SELECT emp_name, salary FROM Employee
WHERE salary > (SELECT AVG(salary) FROM Employee);

-- Query the nested view
SELECT emp_name FROM high_salary;



create a database Then inside MySQL:

CREATE DATABASE companydb;
USE companydb;
-- paste the SQL code above
